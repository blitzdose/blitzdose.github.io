---
title: HardBoot - The hardware boot order switch
date: 2025-10-26 12:00:00 +0100
categories: [Hardware, RP2040, EFI]
tags: [how to, i made a thing]
toc: false
--- 

## Introduction
I lately brought my Hackintosh install back to life on a new PC that I got about a year ago (Yes, I do not use my Hackintosh very often). The setup is pretty simple, I daily drive Windows so that's obviously installed on an M.2 drive. For the MacOS install I put in a second M.2 so I can dual boot my system. Either starting Windows or MacOS.

Because Windows is my daily driver, the UEFI is configured to simply start the Windows boot manager. Whenever I wanted to boot to MacOS I can interrupt the boot process by pressing the key to open the boot menu, select my other M.2, and boot to that drive. This is usually fine but quite annoying when doing updates of the Hackintosh. It happened more than once that I missed the reboot and my PC booted into Windows. 

What is the solution? Some kind of "persistent" switch that configures my boot sequence. 

## Existing solutions
There are two projects that provide a solution for my problem: [https://hackaday.io/project/179539-hardware-boot-selection-switch](https://hackaday.io/project/179539-hardware-boot-selection-switch) and [https://www.hackster.io/Madrajib/hardware-boot-select-switch-using-pico-a3e3d](https://www.hackster.io/Madrajib/hardware-boot-select-switch-using-pico-a3e3d5). Both use a physical switch to configure your boot order, in my opinion the coolest way to select the OS to boot. The way they work is simple, they simulate a mass storage device with a file. The content of the file changes when we use the physical switch. Then, they configure the GRUB bootloader in a way to choose the appropriate boot entry depending on the content of this file.

Do you see the problem? These projects assume that you are a Nerd running Linux with GRUB. Problem is: I am a Nerd running Windows and MacOS (weird, I know), and I do not have GRUB. I _could_ install GRUB to another EFI partition but I want a solution that is completely independent, so I came up with **HardBoot**.

## The most complex solution
I needed a solution with the following requirements:
- Boot an OS depending on a position of a physical switch
- Work completely independent without modifications to the drives in my PC

My first idea was rather simple. Because one of the project is using a Raspberry Pi Pico, which can simulate a mass storage device over USB, I thought "I could install GRUB just to that!". However, after looking at the complexity of GRUB and the size I quickly scrapped that idea. When simulating a mass storage device using the Pico, you get a maximum size of huge 2,031,616... bytes. About two full Megabytes. That's it.

After looking for other bootloaders that are super simple AND are compatible with my idea, I did not found anything. So I did the next totally reasonable thing:

**_I write my own Bootloader!_**

What a great idea! I have zero experience in how the UEFI works. I have zero experience writing operating systems or bootloaders. I have very little experience in C. What could go wrong?

Apparently quite a lot! But with the help of a dozen different AI assistants I actually managed to write a EFI binary, that an UEFI can boot too, that successfully crashes my system. Wohoo!

Jokes aside, I did manage to come up with a solution that I think is quite genius: **HardBoot** will boot either to the second or third boot entry in the UEFI, depending on the position of the switch. This removes the need of configuring the operating systems (I don't know the plural of OS. OSs? OSes? OSese?), in my bootloader. It will just grab the configuration from the UEFI. The resulting C code for this is just 245 lines, of which 14 are very important ASCII art.

## How does it work?
Now it gets technical! To start some code from the UEFI, we need an EFI binary. An EFI binary is in PE32+ format. Yes, that's basically a Windows executable. To make our lives A LOT easier, we will use the [GNU-EFI](https://wiki.osdev.org/GNU-EFI) library which allows us to use a lot of UEFI APIs. The entry point of our binary looks like this:

```c
EFI_STATUS
EFIAPI
efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
    Print(ASCII_ART);
    InitializeLib(ImageHandle, SystemTable);
//[...]
```

We will get an EFI_HANDLE and an EFI_SYSTEM_TABLE from the UEFI. So the obvious first step is to print the important ASCII art. Then we can do the less important step of initializing our code.

After some memory and variable initialization we just need a single line to fetch all the configured boot entries in the UEFI:

```c
Status = uefi_call_wrapper(RT->GetVariable, 5, L"BootOrder", &GlobalVar, NULL, &BootOrderSize, BootOrder);
```

Then, we call some code which will read the file `DATA.TXT`, which will be stored next to our EFI binary. Most of this is AI generated but it basically gets the volume where the currently running EFI binary is stored and reads the first byte of the `DATA.TXT` file, if this byte is `0x01`, then the second boot entry will be used later. If it's `0x02`, the third will be used. This value is actually directly used later so `0x03` for using the fourth entry is also possible.

After that, some more `GetVariable()` is used to correctly fetch the selected boot entry and it's stored configuration. When we successfully got it, we can finally switch to that entry. How do we do it? The UEFI allows us to use two _very_ convenient functions: `LoadImage()` and `StartImage()`.

With `LoadImage()`, we are able to, well, load an image. But an image can be in this case another EFI binary. And again very convenient for us, the previous steps just resulted in a path to another EFI binary. After the binary is loaded, `StartImage()` will hand over execution.

Our flow now looks like this:

```mermaid
  graph TD;
      A-->B;
      A-->C;
      B-->D;
      C-->D;
```